import { Maybe, AnyObject, Optionals } from 'yup/lib/types';
import BaseSchema, { AnySchema } from 'yup/lib/schema';
import { TypeOf, Asserts } from 'yup/lib/util/types';
import { ObjectShape, TypeOfShape, AssertsShape } from 'yup/lib/object';
import Lazy from 'yup/lib/Lazy';
import { MixedSchema } from 'yup';
import moment, { Moment, unitOfTime } from 'moment';

declare class MomentDateSchema extends MixedSchema<Moment> {
    _validFormats: string[];
    constructor({ format, typeError }?: Options$1);
    _typeCheck(value: unknown): value is Moment;
    /**
     * Validate if the date is on or after a specified min
     */
    min(min: string, message?: string): this;
    /**
     * Validate if the date is on or before a specified max
     */
    max(max: string, message?: string): this;
    /**
     * Validate if the date is between a specified min or max
     *
     * For Inlcusivity: `[]` === include & `()` === exclude
     */
    between(min: string, max: string, message?: string, inclusivity?: Inclusivity): this;
    /**
     * Set if the field is required and add a custom message
     */
    isRequired(isRequired?: boolean, message?: string): this;
}
declare type Inclusivity = '()' | '[)' | '(]' | '[]';
declare type Options$1 = {
    format?: string | string[];
    typeError?: string;
};
declare const avDate: (options?: Options$1 | undefined) => MomentDateSchema;

declare class DateRangeSchema extends MixedSchema<DateRange> {
    startKey: string;
    endKey: string;
    format: string;
    constructor(options?: Options);
    /**
     * Convert the string to a moment object
     */
    getValidDate(value: string | Date | Moment): moment.Moment;
    /**
     * Validate based on min and max distance between dates
     */
    distance({ min: { value: minValue, units: minUnits, errorMessage: minErrorMessage }, max: { value: maxValue, units: maxUnits, errorMessage: maxErrorMessage }, }?: DistanceOptions): this;
    /**
     * Validate start date is after given min
     */
    min(min: string, message?: string): this;
    /**
     * Validate end date is before given max
     */
    max(max: string, message?: string): this;
    /**
     * Validate dates are between the set min and max
     */
    between(min: string, max: string, message?: string): this;
    /**
     * Set the field to be required or not
     */
    isRequired(isRequired?: boolean, msg?: string): this;
    typeError({ message }: {
        message: string;
    }): this;
    _typeCheck(range?: {
        startDate?: Moment;
        endDate?: Moment;
    }): range is DateRange;
}
declare type Options = {
    startKey?: string;
    endKey?: string;
    format?: string;
};
declare type DateRange = {
    startDate?: Moment;
    endDate?: Moment;
    supportedFormats?: string[];
};
declare type DistanceValue = {
    value: number;
    units?: unitOfTime.DurationConstructor;
    errorMessage?: string;
};
declare type DistanceOptions = {
    min?: DistanceValue;
    max?: DistanceValue;
};
declare const dateRange: (opts?: Options | undefined) => DateRangeSchema;

declare module 'yup' {
    interface StringSchema<TType extends Maybe<string> = string | undefined, TContext extends AnyObject = AnyObject, TOut extends TType = TType> extends BaseSchema<TType, TContext, TOut> {
        isRequired(required?: boolean, errorMessage?: string): StringSchema<TType, TContext>;
        npi(errorMessage?: string): StringSchema<TType, TContext>;
        phone(errorMessage?: string): StringSchema<TType, TContext>;
    }
    interface NumberSchema<TType extends Maybe<number> = number | undefined, TContext extends AnyObject = AnyObject, TOut extends TType = TType> extends BaseSchema<TType, TContext, TOut> {
        isRequired(required?: boolean, errorMessage?: string): NumberSchema<TType, TContext, TOut>;
        npi(errorMessage?: string): NumberSchema<TType, TContext, TOut>;
        phone(errorMessage?: string): NumberSchema<TType, TContext, TOut>;
    }
    interface ArraySchema<T extends AnySchema | Lazy<any, any>, C extends AnyObject = AnyObject, TIn extends Maybe<TypeOf<T>[]> = TypeOf<T>[] | undefined, TOut extends Maybe<Asserts<T>[]> = Asserts<T>[] | Optionals<TIn>> extends BaseSchema<TIn, C, TOut> {
        isRequired(required?: boolean, errorMessage?: string): ArraySchema<T, C, TIn, TOut>;
    }
    interface ObjectSchema<TShape extends ObjectShape, TContext extends AnyObject = AnyObject, TIn extends Maybe<TypeOfShape<TShape>> = TypeOfShape<TShape>, TOut extends Maybe<AssertsShape<TShape>> = AssertsShape<TShape> | Optionals<TIn>> extends BaseSchema<TIn, TContext, TOut> {
        isRequired(required?: boolean, errorMessage?: string): ObjectSchema<TShape, TContext, TIn, TOut>;
    }
}

export { avDate, dateRange };
